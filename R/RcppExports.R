# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Fit logistic regression using IRLS in C++
#' 
#' @param X A numeric matrix with the desired covariates. If an intercept is 
#' desired, then a column of ones should be part of this input matrix.
#' @param y A vector of responses taking values zero or one. Should be the same
#' length as the number of rows of X.
#' @param beta The initial value of the coefficients.
#' @param iters The maximum number of IRLS iterations to run.
#' @param eps The convergence threshold for the L1 norm between successive
#' iterations of the parameters during the IRLS iteration.
#' 
#' @details
#' This function skips a lot of sanity checks and input validation that the 
#' usual R functions do in the name of speed. There are also no guardrails 
#' against unstable numerical computations.
#' 
#' @returns
#' Returns a list with two elements: `B` which is a matrix where each row is 
#' the parameter at the corresponding IRLS iteration and `cov` is the 
#' Hessian matrix at the final iteration.
#' 
#' @export
Logistic_IRLS <- function(X, y, beta, iters = 10L, eps = 1e-10) {
    .Call(`_doublysketchingglms_Logistic_IRLS`, X, y, beta, iters, eps)
}

Logistic_Iter <- function(Xs, ys, beta) {
    .Call(`_doublysketchingglms_Logistic_Iter`, Xs, ys, beta)
}

#' Fit Binomial-Cloglog GLM using IRLS in C++
#' 
#' @param X A numeric matrix with the desired covariates. If an intercept is 
#' desired, then a column of ones should be part of this input matrix.
#' @param y A vector of responses taking values zero or one. Should be the same
#' length as the number of rows of X.
#' @param beta The initial value of the coefficients.
#' @param iters The maximum number of IRLS iterations to run.
#' @param eps The convergence threshold for the L1 norm between successive
#' iterations of the parameters during the IRLS iteration.
#' 
#' @details
#' This function skips a lot of sanity checks and input validation that the 
#' usual R functions do in the name of speed. Means are clamped to be between
#' approximately 2.2e-16 and 1 - 2.2e-16.
#' 
#' @returns
#' Returns a list with two elements: `B` which is a matrix where each row is 
#' the parameter at the corresponding IRLS iteration and `cov` is the 
#' Hessian matrix at the final iteration.
#' 
#' @export
Cloglog_IRLS <- function(X, y, beta, iters = 10L, eps = 1e-10) {
    .Call(`_doublysketchingglms_Cloglog_IRLS`, X, y, beta, iters, eps)
}

#' Fit Poisson-Log regression using IRLS in C++
#' 
#' @param X A numeric matrix with the desired covariates. If an intercept is 
#' desired, then a column of ones should be part of this input matrix.
#' @param y A vector of responses taking values zero or one. Should be the same
#' length as the number of rows of X.
#' @param beta The initial value of the coefficients.
#' @param iters The maximum number of IRLS iterations to run.
#' @param eps The convergence threshold for the L1 norm between successive
#' iterations of the parameters during the IRLS iteration.
#' 
#' @details
#' This function skips a lot of sanity checks and input validation that the 
#' usual R functions do in the name of speed. There are also no guardrails 
#' against unstable numerical computations.
#' 
#' @returns
#' Returns a list with two elements: `B` which is a matrix where each row is 
#' the parameter at the corresponding IRLS iteration and `cov` is the 
#' Hessian matrix at the final iteration.
#' 
#' @export
Poisson_IRLS <- function(X, y, beta, iters = 10L, eps = 1e-10) {
    .Call(`_doublysketchingglms_Poisson_IRLS`, X, y, beta, iters, eps)
}

#' Fit Gamma-Inverse regression using IRLS in C++
#' 
#' @param X A numeric matrix with the desired covariates. If an intercept is 
#' desired, then a column of ones should be part of this input matrix.
#' @param y A vector of responses taking values zero or one. Should be the same
#' length as the number of rows of X.
#' @param beta The initial value of the coefficients.
#' @param iters The maximum number of IRLS iterations to run.
#' @param eps The convergence threshold for the L1 norm between successive
#' iterations of the parameters during the IRLS iteration.
#' @param backtrack An integer determining the number of times to backtrack an
#' invalid parameter update. Each backtracking step consists of halving the 
#' update difference, which is as done by [stats::glm.fit] internally.
#' 
#' @returns
#' Returns a list with three elements: `B` which is a matrix where each row is 
#' the parameter at the corresponding IRLS iteration, `cov` is the 
#' Hessian matrix at the final iteration, and `dispersion` which is the fitted
#' dispersion value.
#' 
#' @export
Gamma_Inverse_IRLS <- function(X, y, beta, iters = 10L, backtrack = 100L, eps = 1e-10) {
    .Call(`_doublysketchingglms_Gamma_Inverse_IRLS`, X, y, beta, iters, backtrack, eps)
}

#' Fit a weighted Gamma-Inverse regression using IRLS in C++
#' 
#' @description
#' This is a helper function to perform weighted Gamma-Inverse GLM fit for the
#' Optimal Distributed Subsampling for Maximum Quasi-Likelihood Estimators With 
#' Massive Data method by Yu et al. (2022). This is so that the code is similar
#' and so the speeds are comparable.
#' 
#' @param X,y,beta,iters,backtrack,eps As in [Gamma_Inverse_IRLS].
#' @param w A vector of weights.
#' 
#' @returns
#' Returns a list with three elements: `B` which is a matrix where each row is 
#' the parameter at the corresponding IRLS iteration, `cov` is the 
#' Hessian matrix at the final iteration, and `dispersion` which is the fitted
#' dispersion value.
#' 
#' @export
Gamma_Inverse_wIRLS <- function(X, y, w, beta, iters = 10L, backtrack = 100L, eps = 1e-10) {
    .Call(`_doublysketchingglms_Gamma_Inverse_wIRLS`, X, y, w, beta, iters, backtrack, eps)
}

#' Fit a weighted logistic regression using IRLS in C++
#' 
#' @description
#' This is a helper function to perform weighted logistic GLM fit for the
#' Optimal Distributed Subsampling for Maximum Quasi-Likelihood Estimators With 
#' Massive Data method by Yu et al. (2022). This is so that the code is similar
#' and so the speeds are comparable.
#' 
#' @param X,y,beta,iters,eps As in [Logistic_IRLS].
#' @param w A vector of weights.
#' 
#' @returns
#' Returns a list with two elements: `B` which is a matrix where each row is 
#' the parameter at the corresponding IRLS iteration and `cov` is the 
#' Hessian matrix at the final iteration.
#' 
#' @export
Logistic_wIRLS <- function(X, y, w, beta, iters = 10L, eps = 1e-10) {
    .Call(`_doublysketchingglms_Logistic_wIRLS`, X, y, w, beta, iters, eps)
}

#' Fit a weighted Poisson-Log regression using IRLS in C++
#' 
#' @description
#' This is a helper function to perform weighted Poisson-Log GLM fit for the
#' Optimal Distributed Subsampling for Maximum Quasi-Likelihood Estimators With 
#' Massive Data method by Yu et al. (2022). This is so that the code is similar
#' and so the speeds are comparable.
#' 
#' @param X,y,beta,iters,eps As in [Logistic_IRLS].
#' @param w A vector of weights.
#' 
#' @returns
#' Returns a list with two elements: `B` which is a matrix where each row is 
#' the parameter at the corresponding IRLS iteration and `cov` is the 
#' Hessian matrix at the final iteration.
#' 
#' @export
Poisson_wIRLS <- function(X, y, w, beta, iters = 10L, eps = 1e-10) {
    .Call(`_doublysketchingglms_Poisson_wIRLS`, X, y, w, beta, iters, eps)
}

#' Perform doubly-sketching on a logistic regression based on data in memory
#' using C++.
#' 
#' @param X A numeric matrix with the desired covariates. If an intercept is 
#' desired, then a column of ones should be part of this input matrix.
#' @param y A vector of responses taking values zero or one. Should be the same
#' length as the number of rows of X.
#' @param beta The initial value of the coefficients.
#' @param m The size of the first uniform sketch.
#' @param k The size of the second Clarkson-Woodruff sketch. If `k` is larger 
#' than `m`, then the second sketch is omitted.
#' @param iters The number of iterations to run for.
#' @param gamma The regularization constant for the Hessian matrices.
#' @param reset_iter The iteration at which to reset the determinantally 
#' averaged inverse Hessian matrices. Should be set to either 1 or Inf (to 
#' disable resetting).
#' @param reset_length The starting number of iterations between resets. Every
#' reset will increment this length by one internally. Should be set to 1 
#' unless there is a very unusual reason to change this.
#' 
#' @returns
#' Returns a list with two elements: `beta` is the final estimated parameter 
#' estimate, `B` which is a matrix tracing the parameter from iteration to 
#' itertation, and a matrix `Fhat_m_num` and scalar `Fhat_m_den`. Together, 
#' these two latter elements are the determinantal average. The estimate for 
#' the covariance matrix estimate can be obtained by using the expression
#' `Fhat_m_num / Fhat_m_den / m`. The `m` divisor is required as the internal
#' calculation avoids dividing and multiplying by `m` unnecessarily.
#' 
#' @export
Double_Sketch_Binomial_Logit <- function(X, y, beta, m, k, iters = 10L, gamma = 1, reset_iter = 1L, reset_length = 1L) {
    .Call(`_doublysketchingglms_Double_Sketch_Binomial_Logit`, X, y, beta, m, k, iters, gamma, reset_iter, reset_length)
}

Double_Sketch_Binomial_Logit_fold <- function(X, y, beta, m, k, iters = 10L, gamma = 1, reset_iter = 1L, reset_length = 1L) {
    .Call(`_doublysketchingglms_Double_Sketch_Binomial_Logit_fold`, X, y, beta, m, k, iters, gamma, reset_iter, reset_length)
}

CW_Iter_Binomial_Logit <- function(X, y, beta, Fhat_m_num, Fhat_m_den, k, gamma = 1, iter = 1L) {
    .Call(`_doublysketchingglms_CW_Iter_Binomial_Logit`, X, y, beta, Fhat_m_num, Fhat_m_den, k, gamma, iter)
}

CW_Iter_Binomial_Logit_scale <- function(X, y, beta, Fhat_m_num, Fhat_m_den, k, gamma = 1, iter = 1L, scale_xz = 1) {
    .Call(`_doublysketchingglms_CW_Iter_Binomial_Logit_scale`, X, y, beta, Fhat_m_num, Fhat_m_den, k, gamma, iter, scale_xz)
}

Double_Sketch_Poisson_Log <- function(X, y, beta, m, k, iters = 10L, gamma = 1, reset_iter = 1L, reset_length = 1L) {
    .Call(`_doublysketchingglms_Double_Sketch_Poisson_Log`, X, y, beta, m, k, iters, gamma, reset_iter, reset_length)
}

CW_Iter_Poisson_Log <- function(X, y, beta, Fhat_m_num, Fhat_m_den, k, gamma = 1, iter = 1L) {
    .Call(`_doublysketchingglms_CW_Iter_Poisson_Log`, X, y, beta, Fhat_m_num, Fhat_m_den, k, gamma, iter)
}

CW_Iter_Poisson_Log_shuffle <- function(X, y, beta, Fhat_m_num, Fhat_m_den, k, gamma = 1, iter = 1L) {
    .Call(`_doublysketchingglms_CW_Iter_Poisson_Log_shuffle`, X, y, beta, Fhat_m_num, Fhat_m_den, k, gamma, iter)
}

CW_Iter_Poisson_Log_scale <- function(X, y, beta, Fhat_m_num, Fhat_m_den, k, gamma = 1, iter = 1L, scale_xz = 1) {
    .Call(`_doublysketchingglms_CW_Iter_Poisson_Log_scale`, X, y, beta, Fhat_m_num, Fhat_m_den, k, gamma, iter, scale_xz)
}

Double_Sketch_Binomial_Cloglog <- function(X, y, beta, m, k, iters = 10L, gamma = 1, reset_iter = 1L, reset_length = 1L) {
    .Call(`_doublysketchingglms_Double_Sketch_Binomial_Cloglog`, X, y, beta, m, k, iters, gamma, reset_iter, reset_length)
}

Double_Sketch_Binomial_Cloglog_full <- function(X, y, beta, m, k, iters = 10L, gamma = 1, reset_iter = 1L, reset_length = 1L) {
    .Call(`_doublysketchingglms_Double_Sketch_Binomial_Cloglog_full`, X, y, beta, m, k, iters, gamma, reset_iter, reset_length)
}

Double_Sketch_Binomial_Logit_full <- function(X, y, beta, m, k, iters = 10L, gamma = 1, reset_iter = 1L, reset_length = 1L) {
    .Call(`_doublysketchingglms_Double_Sketch_Binomial_Logit_full`, X, y, beta, m, k, iters, gamma, reset_iter, reset_length)
}

Double_Sketch_Poisson_Log_full <- function(X, y, beta, m, k, iters = 10L, gamma = 1, reset_iter = 1L, reset_length = 1L) {
    .Call(`_doublysketchingglms_Double_Sketch_Poisson_Log_full`, X, y, beta, m, k, iters, gamma, reset_iter, reset_length)
}

Double_Sketch_Gamma_Inverse_full <- function(X, y, beta, m, k, iters = 10L, backtrack = 100L, gamma = 1, reset_iter = 1L, reset_length = 1L) {
    .Call(`_doublysketchingglms_Double_Sketch_Gamma_Inverse_full`, X, y, beta, m, k, iters, backtrack, gamma, reset_iter, reset_length)
}

SGD_Binomial_Logit <- function(X, y, beta, m, k, iters = 10L, learningrate = 1) {
    .Call(`_doublysketchingglms_SGD_Binomial_Logit`, X, y, beta, m, k, iters, learningrate)
}

SGD_Gamma_Inverse <- function(X, y, beta, m, k, iters = 10L, learningrate = 1) {
    .Call(`_doublysketchingglms_SGD_Gamma_Inverse`, X, y, beta, m, k, iters, learningrate)
}

